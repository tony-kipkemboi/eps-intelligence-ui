import"./isArrayLikeObject-Cq2qK7Wl.js";import{r as e}from"./_baseUniq-Jlp_hZKC.js";import{s as t}from"./_basePickBy-DMeiC1ak.js";import"./isEmpty-Cf5-89d5.js";import{t as n}from"./dagre-BS9vatpw.js";import"./chunk-S3R3BYOJ-4Io_U-rZ.js";import{t as r}from"./clone-BZeRGxQ_.js";import{t as i}from"./graphlib-DN90-uky.js";import{g as a,h as o}from"./src-DKFOq3Iy.js";import{b as s}from"./chunk-ABZYJK2D-DQqi0gX5.js";import"./path-BLlWIfS-.js";import"./math-BRGfLhAd.js";import"./array-Cc0-LU6d.js";import"./line-BoDiPod3.js";import"./dist-aNbxzeMF.js";import"./chunk-JA3XYJ7Z-lspphA4s.js";import"./chunk-HN2XXSSU-BNfasrTS.js";import{t as c}from"./chunk-CVBHYZKI-Bv50Qmj2.js";import"./chunk-ATLVNIR6-B7CO1nhh.js";import{a as l,c as u,i as d,l as f,n as p,t as m,u as h}from"./chunk-JZLCHNYA-C9ufh29O.js";import{a as g,i as _,n as v,r as y,t as b}from"./chunk-QXUST7PY-BzvRS7nn.js";function x(t){var n={options:{directed:t.isDirected(),multigraph:t.isMultigraph(),compound:t.isCompound()},nodes:S(t),edges:C(t)};return e(t.graph())||(n.value=r(t.graph())),n}function S(n){return t(n.nodes(),function(t){var r=n.node(t),i=n.parent(t),a={v:t};return e(r)||(a.value=r),e(i)||(a.parent=i),a})}function C(n){return t(n.edges(),function(t){var r=n.edge(t),i={v:t.v,w:t.w};return e(t.name)||(i.name=t.name),e(r)||(i.value=r),i})}var w=new Map,T=new Map,E=new Map,D=o(()=>{T.clear(),E.clear(),w.clear()},`clear`),O=o((e,t)=>{let n=T.get(t)||[];return a.trace(`In isDescendant`,t,` `,e,` = `,n.includes(e)),n.includes(e)},`isDescendant`),k=o((e,t)=>{let n=T.get(t)||[];return a.info(`Descendants of `,t,` is `,n),a.info(`Edge is `,e),e.v===t||e.w===t?!1:n?n.includes(e.v)||O(e.v,t)||O(e.w,t)||n.includes(e.w):(a.debug(`Tilt, `,t,`,not in descendants`),!1)},`edgeInCluster`),A=o((e,t,n,r)=>{a.warn(`Copying children of `,e,`root`,r,`data`,t.node(e),r);let i=t.children(e)||[];e!==r&&i.push(e),a.warn(`Copying (nodes) clusterId`,e,`nodes`,i),i.forEach(i=>{if(t.children(i).length>0)A(i,t,n,r);else{let o=t.node(i);a.info(`cp `,i,` to `,r,` with parent `,e),n.setNode(i,o),r!==t.parent(i)&&(a.warn(`Setting parent`,i,t.parent(i)),n.setParent(i,t.parent(i))),e!==r&&i!==e?(a.debug(`Setting parent`,i,e),n.setParent(i,e)):(a.info(`In copy `,e,`root`,r,`data`,t.node(e),r),a.debug(`Not Setting parent for node=`,i,`cluster!==rootId`,e!==r,`node!==clusterId`,i!==e));let s=t.edges(i);a.debug(`Copying Edges`,s),s.forEach(i=>{a.info(`Edge`,i);let o=t.edge(i.v,i.w,i.name);a.info(`Edge data`,o,r);try{k(i,r)?(a.info(`Copying as `,i.v,i.w,o,i.name),n.setEdge(i.v,i.w,o,i.name),a.info(`newGraph edges `,n.edges(),n.edge(n.edges()[0]))):a.info(`Skipping copy of edge `,i.v,`-->`,i.w,` rootId: `,r,` clusterId:`,e)}catch(e){a.error(e)}})}a.debug(`Removing node`,i),t.removeNode(i)})},`copy`),j=o((e,t)=>{let n=t.children(e),r=[...n];for(let i of n)E.set(i,e),r=[...r,...j(i,t)];return r},`extractDescendants`),M=o((e,t,n)=>{let r=e.edges().filter(e=>e.v===t||e.w===t),i=e.edges().filter(e=>e.v===n||e.w===n),a=r.map(e=>({v:e.v===t?n:e.v,w:e.w===t?t:e.w})),o=i.map(e=>({v:e.v,w:e.w}));return a.filter(e=>o.some(t=>e.v===t.v&&e.w===t.w))},`findCommonEdges`),N=o((e,t,n)=>{let r=t.children(e);if(a.trace(`Searching children of id `,e,r),r.length<1)return e;let i;for(let e of r){let r=N(e,t,n),a=M(t,n,r);if(r)if(a.length>0)i=r;else return r}return i},`findNonClusterChild`),P=o(e=>!w.has(e)||!w.get(e).externalConnections?e:w.has(e)?w.get(e).id:e,`getAnchorId`),F=o((e,t)=>{if(!e||t>10){a.debug(`Opting out, no graph `);return}else a.debug(`Opting in, graph `);e.nodes().forEach(function(t){e.children(t).length>0&&(a.warn(`Cluster identified`,t,` Replacement id in edges: `,N(t,e,t)),T.set(t,j(t,e)),w.set(t,{id:N(t,e,t),clusterData:e.node(t)}))}),e.nodes().forEach(function(t){let n=e.children(t),r=e.edges();n.length>0?(a.debug(`Cluster identified`,t,T),r.forEach(e=>{O(e.v,t)^O(e.w,t)&&(a.warn(`Edge: `,e,` leaves cluster `,t),a.warn(`Descendants of XXX `,t,`: `,T.get(t)),w.get(t).externalConnections=!0)})):a.debug(`Not a cluster `,t,T)});for(let t of w.keys()){let n=w.get(t).id,r=e.parent(n);r!==t&&w.has(r)&&!w.get(r).externalConnections&&(w.get(t).id=r)}e.edges().forEach(function(t){let n=e.edge(t);a.warn(`Edge `+t.v+` -> `+t.w+`: `+JSON.stringify(t)),a.warn(`Edge `+t.v+` -> `+t.w+`: `+JSON.stringify(e.edge(t)));let r=t.v,i=t.w;if(a.warn(`Fix XXX`,w,`ids:`,t.v,t.w,`Translating: `,w.get(t.v),` --- `,w.get(t.w)),w.get(t.v)||w.get(t.w)){if(a.warn(`Fixing and trying - removing XXX`,t.v,t.w,t.name),r=P(t.v),i=P(t.w),e.removeEdge(t.v,t.w,t.name),r!==t.v){let i=e.parent(r);w.get(i).externalConnections=!0,n.fromCluster=t.v}if(i!==t.w){let r=e.parent(i);w.get(r).externalConnections=!0,n.toCluster=t.w}a.warn(`Fix Replacing with XXX`,r,i,t.name),e.setEdge(r,i,n,t.name)}}),a.warn(`Adjusted Graph`,x(e)),I(e,0),a.trace(w)},`adjustClustersAndEdges`),I=o((e,t)=>{if(a.warn(`extractor - `,t,x(e),e.children(`D`)),t>10){a.error(`Bailing out`);return}let n=e.nodes(),r=!1;for(let t of n){let n=e.children(t);r||=n.length>0}if(!r){a.debug(`Done, no node has children`,e.nodes());return}a.debug(`Nodes = `,n,t);for(let r of n)if(a.debug(`Extracting node`,r,w,w.has(r)&&!w.get(r).externalConnections,!e.parent(r),e.node(r),e.children(`D`),` Depth `,t),!w.has(r))a.debug(`Not a cluster`,r,t);else if(!w.get(r).externalConnections&&e.children(r)&&e.children(r).length>0){a.warn(`Cluster without external connections, without a parent and with children`,r,t);let n=e.graph().rankdir===`TB`?`LR`:`TB`;w.get(r)?.clusterData?.dir&&(n=w.get(r).clusterData.dir,a.warn(`Fixing dir`,w.get(r).clusterData.dir,n));let o=new i({multigraph:!0,compound:!0}).setGraph({rankdir:n,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});a.warn(`Old graph before copy`,x(e)),A(r,e,o,r),e.setNode(r,{clusterNode:!0,id:r,clusterData:w.get(r).clusterData,label:w.get(r).label,graph:o}),a.warn(`New graph after copy node: (`,r,`)`,x(o)),a.debug(`Old graph after copy`,x(e))}else a.warn(`Cluster ** `,r,` **not meeting the criteria !externalConnections:`,!w.get(r).externalConnections,` no parent: `,!e.parent(r),` children `,e.children(r)&&e.children(r).length>0,e.children(`D`),t),a.debug(w);n=e.nodes(),a.warn(`New list of nodes`,n);for(let r of n){let n=e.node(r);a.warn(` Now next level`,r,n),n?.clusterNode&&I(n.graph,t+1)}},`extractor`),L=o((e,t)=>{if(t.length===0)return[];let n=Object.assign([],t);return t.forEach(t=>{let r=L(e,e.children(t));n=[...n,...r]}),n},`sorter`),R=o(e=>L(e,e.children()),`sortNodesByHierarchy`),z=o(async(e,t,r,i,s,p)=>{a.warn(`Graph in recursive render:XAX`,x(t),s);let m=t.graph().rankdir;a.trace(`Dir in recursive render - dir:`,m);let _=e.insert(`g`).attr(`class`,`root`);t.nodes()?a.info(`Recursive render XXX`,t.nodes()):a.info(`No nodes found for`,t),t.edges().length>0&&a.info(`Recursive edges`,t.edge(t.edges()[0]));let b=_.insert(`g`).attr(`class`,`clusters`),S=_.insert(`g`).attr(`class`,`edgePaths`),C=_.insert(`g`).attr(`class`,`edgeLabels`),T=_.insert(`g`).attr(`class`,`nodes`);await Promise.all(t.nodes().map(async function(e){let n=t.node(e);if(s!==void 0){let n=JSON.parse(JSON.stringify(s.clusterData));a.trace(`Setting data for parent cluster XXX
 Node.id = `,e,`
 data=`,n.height,`
Parent cluster`,s.height),t.setNode(s.id,n),t.parent(e)||(a.trace(`Setting parent`,e,s.id),t.setParent(e,s.id,n))}if(a.info(`(Insert) Node XXX`+e+`: `+JSON.stringify(t.node(e))),n?.clusterNode){a.info(`Cluster identified XBX`,e,n.width,t.node(e));let{ranksep:o,nodesep:s}=t.graph();n.graph.setGraph({...n.graph.graph(),ranksep:o+25,nodesep:s});let c=await z(T,n.graph,r,i,t.node(e),p),l=c.elem;h(n,l),n.diff=c.diff||0,a.info(`New compound node after recursive render XAX`,e,`width`,n.width,`height`,n.height),f(l,n)}else t.children(e).length>0?(a.trace(`Cluster - the non recursive path XBX`,e,n.id,n,n.width,`Graph:`,t),a.trace(N(n.id,t)),w.set(n.id,{id:N(n.id,t),node:n})):(a.trace(`Node - the non recursive path XAX`,e,T,t.node(e),m),await l(T,t.node(e),{config:p,dir:m}))})),await o(async()=>{let e=t.edges().map(async function(e){let n=t.edge(e.v,e.w,e.name);a.info(`Edge `+e.v+` -> `+e.w+`: `+JSON.stringify(e)),a.info(`Edge `+e.v+` -> `+e.w+`: `,e,` `,JSON.stringify(t.edge(e))),a.info(`Fix`,w,`ids:`,e.v,e.w,`Translating: `,w.get(e.v),w.get(e.w)),await y(C,n)});await Promise.all(e)},`processEdges`)(),a.info(`Graph before layout:`,JSON.stringify(x(t))),a.info(`############################################# XXX`),a.info(`###                Layout                 ### XXX`),a.info(`############################################# XXX`),n(t),a.info(`Graph after layout:`,JSON.stringify(x(t)));let E=0,{subGraphTitleTotalMargin:D}=c(p);return await Promise.all(R(t).map(async function(e){let n=t.node(e);if(a.info(`Position XBX => `+e+`: (`+n.x,`,`+n.y,`) width: `,n.width,` height: `,n.height),n?.clusterNode)n.y+=D,a.info(`A tainted cluster node XBX1`,e,n.id,n.width,n.height,n.x,n.y,t.parent(e)),w.get(n.id).node=n,u(n);else if(t.children(e).length>0){a.info(`A pure cluster node XBX1`,e,n.id,n.x,n.y,n.width,n.height,t.parent(e)),n.height+=D,t.node(n.parentId);let r=n?.padding/2||0,i=n?.labelBBox?.height||0,o=i-r||0;a.debug(`OffsetY`,o,`labelHeight`,i,`halfPadding`,r),await d(b,n),w.get(n.id).node=n}else{let e=t.node(n.parentId);n.y+=D/2,a.info(`A regular node XBX1 - using the padding`,n.id,`parent`,n.parentId,n.width,n.height,n.x,n.y,`offsetY`,n.offsetY,`parent`,e,e?.offsetY,n),u(n)}})),t.edges().forEach(function(e){let n=t.edge(e);a.info(`Edge `+e.v+` -> `+e.w+`: `+JSON.stringify(n),n),n.points.forEach(e=>e.y+=D/2),g(n,v(S,n,w,r,t.node(e.v),t.node(e.w),i))}),t.nodes().forEach(function(e){let n=t.node(e);a.info(e,n.type,n.diff),n.isGroup&&(E=n.diff)}),a.warn(`Returning from recursive render XAX`,_,E),{elem:_,diff:E}},`recursiveRender`),B=o(async(e,t)=>{let n=new i({multigraph:!0,compound:!0}).setGraph({rankdir:e.direction,nodesep:e.config?.nodeSpacing||e.config?.flowchart?.nodeSpacing||e.nodeSpacing,ranksep:e.config?.rankSpacing||e.config?.flowchart?.rankSpacing||e.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}}),r=t.select(`g`);_(r,e.markers,e.type,e.diagramId),p(),b(),m(),D(),e.nodes.forEach(e=>{n.setNode(e.id,{...e}),e.parentId&&n.setParent(e.id,e.parentId)}),a.debug(`Edges:`,e.edges),e.edges.forEach(e=>{if(e.start===e.end){let t=e.start,r=t+`---`+t+`---1`,i=t+`---`+t+`---2`,a=n.node(t);n.setNode(r,{domId:r,id:r,parentId:a.parentId,labelStyle:``,label:``,padding:0,shape:`labelRect`,style:``,width:10,height:10}),n.setParent(r,a.parentId),n.setNode(i,{domId:i,id:i,parentId:a.parentId,labelStyle:``,padding:0,shape:`labelRect`,label:``,style:``,width:10,height:10}),n.setParent(i,a.parentId);let o=structuredClone(e),s=structuredClone(e),c=structuredClone(e);o.label=``,o.arrowTypeEnd=`none`,o.id=t+`-cyclic-special-1`,s.arrowTypeStart=`none`,s.arrowTypeEnd=`none`,s.id=t+`-cyclic-special-mid`,c.label=``,a.isGroup&&(o.fromCluster=t,c.toCluster=t),c.id=t+`-cyclic-special-2`,c.arrowTypeStart=`none`,n.setEdge(t,r,o,t+`-cyclic-special-0`),n.setEdge(r,i,s,t+`-cyclic-special-1`),n.setEdge(i,t,c,t+`-cyc<lic-special-2`)}else n.setEdge(e.start,e.end,{...e},e.id)}),a.warn(`Graph at first:`,JSON.stringify(x(n))),F(n),a.warn(`Graph after XAX:`,JSON.stringify(x(n)));let o=s();await z(r,n,e.type,e.diagramId,void 0,o)},`render`);export{B as render};